Cilj projekta je realizacija BLE uređaja na bazi ESP32-S3 platforme u ulozi BLE klijenta. BLE uređaj treba da preuzima podatke o temperaturi, vazdušnom pritisku i relativnoj vlažnosti od Thingy:52 senzora i štampa ih preko serijskog terminala.
Neposredno nakon uspostavljanja BLE konekcije sa Thingy:52
 BLE klijent šalje komandu Thingy:52 za generisanje kratkotrajnog tona kao potvrdu uspešne konekcije.
Tokom trajanja BLE konekcije, uređaj treba da:
 Prima notifikacije od Thingy:52 koje sadrže podatke o temperaturi, vazdušnom pritisku i relativnoj vlažnosti.
 Štampa svaki primljeni podatak na serijskom monitoru.
Napomena 1: Program treba organizovati po ugledu na premer „ESP32-S3 BLE klijent“: periodično skeniranje, konektovanje, povratak na skeniranje nakon raskida konekcije. U odnosu „ESP32-S3 BLE klijent“, program koji treba da napišete će biti obimniji, jer treba da ostvari vezu sa dva servisa i ukupno četiri karakteristike. Takođe, tri karakteristike podržavaju notifikacije, i za svaku od njih je potrebno predvideti posebnu callback funkciju za notifikaciju.
Napomena 2: U paketima za oglašavanje koje emituje Thingy:52 nisu uvršteni UUID-ovi svih podržanih servisa, već samo UUID servisa Thingy Configuration Service: EF680100-9B35-4933-9B10-52FFA9740042
To znači da kao kriterijum za otkrivanje uređaja u callback funkciji BLE skenera treba koristiti ovaj UUID.
Napomena 3: Podaci koji pristižu notifikacijama dolaze kao niz bajtova, zato je potrebno obratiti pažnju na specifikaciju njihovog formata (Sl. 6 i Sl. 7). Na primer, podatak o temperaturi sadrži dva bajta: prvi predstavlja celobrojni, a drugi razlomljeni deo vrednosti temperature. Podatak o pritisku sadrži čak 5 bajta:prva 4 su celobrojni, peti razlomljeni deo. Prva četiri bajta se tumače kao 32-bitni ceo broj u little endian formatu. Na primer, ako u notifikaciji karakteristike za pritisak dobijemo niz bajtova: 0xE0, 0x03, 0x00, 0x00, 0x49, zapravo smo dobili vrednost 992.73 𝑃𝑎 (Paskala). (0xE0, 0x03) je niža, a (0x00, 0x00) viša 16-bitna reč celobrojnog dela. U okviru svake 16-bitne reči, na početku je viši, a onda niži bajt.
Napomena 4: Radi generisanja tona nakon uspostavljene konekcije nije potrebno podešavati režim rada zvučnika upisom u karakteristiku Config characteristic – oslonićemo se na podrazumevano podešavanje. Potrebno je samo izvršiti upis vrednosti u karakteristiku Speaker data characteristic, koja je dužine 5 bajta: dva uint16_t i jedan uint8_t. Međutim, to ne znači da treba tri puta pozivati funkciju writeValue(), za svaki pojedinačni podatak po jednom, već je potrebno tri podatka, na odgovarajući način, spakovati u niz od 5 bajt i funkciju writeValue() pozvati samo jedanput. Na primer, za frekvenciju 500𝐻𝑧, trajanje 1000𝑚𝑠 i jačinu zvuka 80%, sadržaj niza bajtova bi bio: „F401E80350“. Prve 4 hex cifre predstavljaju 16-bitnu vrednost 500 u little endian formatu – prvo niži, pa viši bajt. Slično, „E803“ je 1000 (little endian), dok je „50“, naravno vrednost 8010. Niz bajtova se može deklarisati npr. ovako:
uint8_t soundArray[5] = {0xF4,0x01,0xE8,0x03,0x50};
Ili se može popunjavati programskim putem, bajt po bajt.
Napomena 5: Prilikom provere prava upisa karakteristike Speaker data characteristic, umesto funkcije canWrite(), koja je korišćena u primeru „ESP32-S3 BLE klijent“, potrebno je koristiti funkciju canWriteNoResponse(). To je zato što ova karakteristika dopušta isključivo upis bez potvrde upisa
